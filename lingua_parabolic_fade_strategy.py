"""
Lingua_Parabolic_Fade Strategy Implementation
Generated by WZRD AI Strategy Architect

Strategy Type: Mean Reversion (Multi-timeframe context, intraday execution)
Market: Large-cap US equities
Timeframe: 15m (context) + 5m (triggers); intraday only
Risk Level: Moderateâ€“Aggressive (pyramiding, ATR-based stops)
"""

import numpy as np
import pandas as pd
from typing import Dict, Tuple, Optional, List, Any
from dataclasses import dataclass
from datetime import datetime, time
import warnings
warnings.filterwarnings('ignore')

@dataclass
class Lingua_parabolic_fadeConfig:
    """Configuration for Lingua_Parabolic_Fade strategy."""

    # Scan Filters
    min_volume: float = 8000000.0
    min_dollar_volume: float = 300000000
    gap_threshold_atr: float = 0.75

    # Risk Management
    risk_per_trade: float = 0.01
    max_portfolio_heat: float = 0.2

    # Technical Indicators
    context_ema: int = 72
    execution_ema: int = 89
    atr_period: int = 14

class Lingua_parabolic_fadeStrategy:
    """
    Lingua_Parabolic_Fade Strategy Implementation

    This is a sophisticated multi-timeframe mean reversion strategy
    targeting parabolic exhaustion in large-cap equities.
    """

    def __init__(self, config: Lingua_parabolic_fadeConfig = None):
        self.config = config or Lingua_parabolic_fadeConfig()
        self.positions = dict()
        self.account_size = 100_000

    def calculate_atr(self, data: pd.DataFrame, period: int = 14) -> pd.Series:
        """Calculate Average True Range."""
        high = data['high']
        low = data['low']
        close = data['close'].shift(1)

        tr1 = high - low
        tr2 = np.abs(high - close)
        tr3 = np.abs(low - close)

        true_range = np.maximum(tr1, np.maximum(tr2, tr3))
        return true_range.rolling(window=period).mean()

    def calculate_ema(self, data: pd.Series, span: int) -> pd.Series:
        """Calculate Exponential Moving Average."""
        return data.ewm(span=span, adjust=False).mean()

    def scan_for_setups(self, data: pd.DataFrame) -> bool:
        """Apply scan filters to identify potential setups."""
        if len(data) < max(self.config.context_ema, self.config.atr_period):
            return False

        # Volume filter
        avg_volume = data['volume'].tail(7).mean()
        if avg_volume < self.config.min_volume:
            return False

        # Gap filter
        atr = self.calculate_atr(data).iloc[-1]
        current_gap = (data['open'].iloc[-1] - data['close'].iloc[-2]) / data['close'].iloc[-2]

        if current_gap < self.config.gap_threshold_atr * atr / data['close'].iloc[-2]:
            return False

        return True

    def generate_signals(self, data_15m: pd.DataFrame, data_5m: pd.DataFrame) -> Dict[str, Any]:
        """Generate entry and exit signals based on multi-timeframe analysis."""
        signals = dict()

        if len(data_15m) < self.config.context_ema or len(data_5m) < 10:
            return signals

        # Calculate context EMAs on 15m
        ema_72_15m = self.calculate_ema(data_15m['close'], self.config.context_ema)
        ema_89_15m = self.calculate_ema(data_15m['close'], self.config.execution_ema)

        # Check for extension into EMA bands (context setup)
        current_price = data_5m['close'].iloc[-1]
        context_ema = ema_72_15m.iloc[-1]

        # Entry signal: extension into 15m EMA72 band + 5m bar break
        if current_price > context_ema * 1.02:  # 2% extension threshold
            # Check for 5m bar break (current bar closes below previous low)
            if (len(data_5m) >= 2 and
                data_5m['close'].iloc[-1] < data_5m['low'].iloc[-2]):
                signals['entry_short'] = True
                signals['entry_price'] = data_5m['close'].iloc[-1]
                signals['context_level'] = context_ema

        # Exit signals based on 15m structure
        if ema_72_15m.iloc[-1] > data_15m['close'].iloc[-1]:
            signals['exit_partial_1'] = True

        if ema_89_15m.iloc[-1] > data_15m['close'].iloc[-1]:
            signals['exit_partial_2'] = True

        return signals

    def calculate_position_size(self, entry_price: float, stop_distance: float) -> float:
        """Calculate position size based on risk management rules."""
        risk_amount = self.account_size * self.config.risk_per_trade
        position_size = risk_amount / stop_distance

        # Cap position at 10% of account
        max_position_value = self.account_size * 0.10
        max_shares = max_position_value / entry_price

        return min(position_size, max_shares)

def run_simple_test():
    """Run a simple test of the strategy."""
    print("ðŸš€ Testing Lingua_Parabolic_Fade Strategy Implementation")
    print("=" * 50)

    # Create strategy instance
    config = Lingua_parabolic_fadeConfig()
    strategy = Lingua_parabolic_fadeStrategy(config)

    print(f"âœ“ Strategy initialized")
    print(f"  - Min Volume: {config.min_volume:,}")
    print(f"  - Gap Threshold: {config.gap_threshold_atr} Ã— ATR")
    print(f"  - Risk Per Trade: {config.risk_per_trade:.1%}")
    print(f"  - Max Portfolio Heat: {config.max_portfolio_heat:.1%}")

    # Generate sample data for testing
    dates = pd.date_range(start='2024-01-01', end='2024-01-31', freq='15T')
    dates = dates[dates.indexer_between_time('09:30', '16:00')]

    np.random.seed(42)
    n_periods = len(dates)

    # Create realistic price data
    close_prices = 100 * (1 + np.cumsum(np.random.randn(n_periods) * 0.001))
    data_15m = pd.DataFrame({
        'timestamp': dates,
        'open': close_prices * (1 + np.random.randn(n_periods) * 0.001),
        'high': close_prices * (1 + np.abs(np.random.randn(n_periods)) * 0.005),
        'low': close_prices * (1 - np.abs(np.random.randn(n_periods)) * 0.005),
        'close': close_prices,
        'volume': np.random.randint(1_000_000, 10_000_000, n_periods)
    })

    # Test scan filters
    scan_result = strategy.scan_for_setups(data_15m.tail(100))
    print(f"\nðŸ“Š Scan Results: {'Pass' if scan_result else 'Fail'}")

    # Test signal generation (using same data for both timeframes for simplicity)
    signals = strategy.generate_signals(data_15m.tail(50), data_15m.tail(50))
    print(f"ðŸ“ˆ Signals Generated: {len(signals)} signals")

    for signal_type, value in signals.items():
        print(f"  - {signal_type}: {value}")

    print(f"\nâœ… Lingua_Parabolic_Fade strategy test completed successfully!")

if __name__ == "__main__":
    run_simple_test()
