"""
Strategy Viewer - Visualize and verify strategy signals from Signal Codifier
This is the final verification step in your streamlined workflow:
Web Chat → Signal Codifier → Strategy Viewer
"""
import streamlit as st
import pandas as pd
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from datetime import datetime, timedelta
import json
import os
import pytz
from dotenv import load_dotenv
from chart_templates import get_template, CHART_STYLE

# Load environment variables
load_dotenv()

# Strategy artifact format expected from Signal Codifier
STRATEGY_ARTIFACT_SCHEMA = {
    "strategy_name": "Strategy_Name",
    "description": "Strategy description",
    "timeframe": "5min",
    "symbol": "SPY",
    "entry_conditions": [
        {
            "type": "multi_timeframe_alignment",
            "description": "HTF trend + MTF setup + LTF execution",
            "direction": "long",
            "indicators": ["ema50", "ema200", "vwap", "rsi", "volume"],
            "htf_condition": "Daily 50EMA > 200EMA",
            "mtf_condition": "15min pullback to VWAP",
            "ltf_condition": "5min RSI oversold bounce"
        }
    ],
    "exit_conditions": [
        {
            "type": "profit_target",
            "description": "Take profit at target",
            "direction": "close_long"
        }
    ],
    "risk_management": {
        "stop_loss": {"type": "percentage", "value": 1.5},
        "take_profit": {"type": "r_multiple", "value": 2.0},
        "position_size": {"type": "r_based", "value": 1.0},
        "pyramiding": {
            "enabled": True,
            "max_legs": 3,
            "add_conditions": [
                {"level": "initial", "size_r": 0.25, "condition": "Initial entry"},
                {"level": "confirmation", "size_r": 0.25, "condition": "Price confirmation"},
                {"level": "continuation", "size_r": 0.5, "condition": "Trend continuation"}
            ]
        }
    },
    "signals": [
        # These are generated by Signal Codifier (code-true signals)
        {
            "timestamp": "2025-09-30 10:00:00",
            "type": "entry_long",
            "price": 450.25,
            "shares": 56,
            "position_id": "SPY-2025-09-30-A",
            "leg": 1,
            "r_allocation": 0.25,
            "reason": "Multi-timeframe alignment detected",
            "execution": "BOUGHT 56 shares @ $450.25",
            "calculation": "stop 443.50 (risk $6.75) → shares=floor($250 / 6.75)=37 → 56 with pyramiding rules",
            "pnl": 0.0
        }
    ],
    "performance_metrics": {
        "total_trades": 0,
        "winning_trades": 0,
        "losing_trades": 0,
        "win_rate": 0,
        "total_pnl": 0,
        "profit_factor": 0,
        "expectancy_per_r": 0,
        "max_drawdown": 0,
        "average_win": 0,
        "average_loss": 0,
        "largest_win": 0,
        "largest_loss": 0
    },
    "provenance": {
        "generated_by": "rules_engine",
        "data_source": "intraday_ohlcv",
        "rule_version": "v1.0.0",
        "generation_timestamp": "2025-10-01T10:17:15.597336",
        "code_hash": "4db51b83"
    }
}

def load_strategy_artifact(artifact_json):
    """Load a strategy artifact from JSON"""
    if isinstance(artifact_json, str):
        return json.loads(artifact_json)
    return artifact_json

def get_signal_date_range(signals):
    """Extract min/max dates from signals array"""
    if not signals:
        return None, None

    timestamps = [pd.to_datetime(s["timestamp"]) for s in signals]
    return min(timestamps), max(timestamps)

def create_mock_data(symbol, timeframe, days_back=5):
    """Create mock market data for testing when API fails"""
    import numpy as np
    from datetime import datetime, timedelta

    # Generate date range
    end_date = datetime.now()
    start_date = end_date - timedelta(days=days_back)

    # Determine frequency based on timeframe
    if timeframe == "5min":
        freq = "5min"
        market_hours_start = 9.5  # 9:30 AM
        market_hours_end = 16.0   # 4:00 PM
        bars_per_day = int((market_hours_end - market_hours_start) * 60 / 5)
    elif timeframe == "15min":
        freq = "15min"
        market_hours_start = 9.5
        market_hours_end = 16.0
        bars_per_day = int((market_hours_end - market_hours_start) * 60 / 15)
    elif timeframe == "hour":
        freq = "1H"
        market_hours_start = 9.5
        market_hours_end = 16.0
        bars_per_day = int(market_hours_end - market_hours_start)
    else:  # daily
        freq = "1D"
        market_hours_start = 9.5
        market_hours_end = 16.0
        bars_per_day = 1

    # Generate date range for trading days only
    dates = pd.date_range(start=start_date, end=end_date, freq='D')
    trading_dates = [d for d in dates if d.weekday() < 5]  # Monday to Friday

    # Generate price data
    all_data = []
    base_price = 100.0  # Starting price

    for date in trading_dates:
        if timeframe == "day":
            # Daily data
            daily_change = np.random.normal(0, 0.02)  # 2% daily volatility
            open_price = base_price
            close_price = base_price * (1 + daily_change)
            high_price = max(open_price, close_price) * (1 + abs(np.random.normal(0, 0.005)))
            low_price = min(open_price, close_price) * (1 - abs(np.random.normal(0, 0.005)))
            volume = np.random.randint(1000000, 5000000)

            all_data.append({
                'date': date,
                'open': open_price,
                'high': high_price,
                'low': low_price,
                'close': close_price,
                'volume': volume
            })

            base_price = close_price
        else:
            # Intraday data
            daily_dates = pd.date_range(
                start=date.replace(hour=int(market_hours_start), minute=int((market_hours_start % 1) * 60)),
                end=date.replace(hour=int(market_hours_end), minute=int((market_hours_end % 1) * 60)),
                freq=freq
            )

            for i, timestamp in enumerate(daily_dates):
                if i == 0:
                    open_price = base_price
                else:
                    open_price = all_data[-1]['close']

                # Generate price movement
                change = np.random.normal(0, 0.001)  # 0.1% volatility per bar
                close_price = open_price * (1 + change)
                high_price = max(open_price, close_price) * (1 + abs(np.random.normal(0, 0.0005)))
                low_price = min(open_price, close_price) * (1 - abs(np.random.normal(0, 0.0005)))
                volume = np.random.randint(10000, 100000)

                all_data.append({
                    'date': timestamp,
                    'open': open_price,
                    'high': high_price,
                    'low': low_price,
                    'close': close_price,
                    'volume': volume
                })

            base_price = close_price

    df = pd.DataFrame(all_data)
    return df

@st.cache_data(ttl=300)  # Cache for 5 minutes
def fetch_market_data(symbol, timeframe, days_back, use_mock=False):
    """Fetch and cache market data with mock fallback"""
    if use_mock:
        st.info("🎭 Using mock data for testing")
        return create_mock_data(symbol, timeframe, days_back)

    try:
        from wzrd_mini_chart import get_polygon_data
        data = get_polygon_data(symbol, timeframe, days_back)
        if data is not None and not data.empty:
            return data
        else:
            st.warning("⚠️ Real data not available, falling back to mock data")
            return create_mock_data(symbol, timeframe, days_back)
    except Exception as e:
        st.warning(f"⚠️ API error ({str(e)}), using mock data")
        return create_mock_data(symbol, timeframe, days_back)

def create_strategy_chart(strategy_artifact, use_mock_data=False, selected_ticker=None, days_back=None, start_date=None, end_date=None):
    """Create a chart with strategy signals overlaid"""
    from wzrd_mini_chart import create_chart
    from datetime import datetime

    # Get the base chart
    template = get_template(strategy_artifact.get("timeframe", "15min"))

    # Fetch data
    symbol = selected_ticker or strategy_artifact.get("symbol", "SPY")
    timeframe = strategy_artifact.get("timeframe", "15min")
    signals = strategy_artifact.get("signals", [])

    # Calculate days_back - prioritize user selection, then signal dates
    if days_back is not None:
        # User specified days_back via UI
        data_days_back = days_back
        st.info(f"📅 Using user-specified date range: {data_days_back} days back")
    else:
        # Calculate days_back based on signal dates (signal-aware fetching)
        min_signal_date, max_signal_date = get_signal_date_range(signals)

        if min_signal_date and max_signal_date:
            # Calculate the date range needed to cover all signals
            # Add 1 day before earliest signal for context
            days_since_earliest = (datetime.now().date() - min_signal_date.date()).days + 1

            # Calculate how many days span the signals themselves
            signal_span_days = (max_signal_date.date() - min_signal_date.date()).days + 2  # +2 for padding

            # Use the larger of: days since earliest signal OR signal span + warmup
            # This ensures we get enough data even if signals are old
            data_days_back = max(days_since_earliest, signal_span_days + 5)  # +5 days for warmup
            data_days_back = min(data_days_back, 30)  # Cap at 30 days for performance

            st.info(f"📅 Fetching data from {min_signal_date.date()} to cover {len(signals)} signals")
        else:
            # Fallback to template default if no signals
            data_days_back = template["default_days"]

    # Fetch market data with caching
    data = fetch_market_data(symbol, timeframe, data_days_back, use_mock_data)

    if data is None or data.empty:
        st.error(f"❌ Could not fetch data for {symbol} on {timeframe} timeframe")
        return None

    # Ensure 'date' column is datetime (data comes from get_polygon_data with 'date' column)
    if 'date' in data.columns:
        data['date'] = pd.to_datetime(data['date'])

    # Debug: Show actual data range
    st.info(f"📊 Data range: {data['date'].min().date()} to {data['date'].max().date()} ({len(data)} bars)")

    # Filter data to only show signal date range (if signals exist)
    if min_signal_date and max_signal_date:
        # Add 1 day padding on each side
        filter_start = min_signal_date - pd.Timedelta(days=1)
        filter_end = max_signal_date + pd.Timedelta(days=1)

        # If data date column is timezone-aware, make filter dates timezone-aware too
        if data['date'].dt.tz is not None:
            import pytz
            if filter_start.tzinfo is None:
                eastern = pytz.timezone('US/Eastern')
                filter_start = eastern.localize(filter_start)
                filter_end = eastern.localize(filter_end)

        # Filter data to this range
        data = data[(data['date'] >= filter_start) & (data['date'] <= filter_end)]

        if data.empty:
            st.error(f"❌ No data found in signal date range: {filter_start.date()} to {filter_end.date()}")
            return None

        st.success(f"✅ Filtered to signal range: {data['date'].min().date()} to {data['date'].max().date()} ({len(data)} bars)")

    # Create base chart with template defaults
    indicator_defaults = template.get("indicators", {})
    fig = create_chart(
        data,
        symbol,
        timeframe,
        display_bars=None,
        show_vwap=indicator_defaults.get("vwap", True),
        show_prev_close=indicator_defaults.get("prev_close", True),
        show_920_bands=indicator_defaults.get("920_bands", True),
        show_920_cloud=indicator_defaults.get("920_cloud", True),
        show_7289_bands=indicator_defaults.get("7289_bands", True),
        show_7289_cloud=indicator_defaults.get("7289_cloud", True)
    )

    # Overlay signals
    signals = strategy_artifact.get("signals", [])

    for signal in signals:
        timestamp = pd.to_datetime(signal["timestamp"])

        # Make timestamp timezone-aware for intraday data (15min, 5min, hour)
        # to match the timezone-aware data from Polygon API
        if timeframe in ["15min", "5min", "hour"] and timestamp.tzinfo is None:
            import pytz
            eastern = pytz.timezone('US/Eastern')
            timestamp = eastern.localize(timestamp)

        price = signal["price"]
        signal_type = signal["type"]

        # Snap timestamp to nearest actual candle in the data
        if timestamp not in data['date'].values:
            # Find nearest candle timestamp
            time_diffs = abs(data['date'] - timestamp)
            nearest_idx = time_diffs.argmin()
            timestamp = data.iloc[nearest_idx]['date']

            # Use the actual close price of that candle for more realistic placement
            # But show the signal's intended price in the hover text
            actual_price = data.iloc[nearest_idx]['close']
        else:
            actual_price = price

        # Determine marker style based on signal type
        if "entry_long" in signal_type:
            # Green arrow pointing up for long entries
            marker_color = "#00FF00"  # Bright green
            marker_symbol = "arrow-up"
            marker_size = 20
            marker_line_color = "#000000"  # Black outline
            text = f"ENTRY LONG<br>{signal.get('reason', '')}<br>Price: ${actual_price:.2f}"
        elif "entry_short" in signal_type:
            # Red arrow pointing down for short entries
            marker_color = "#FF0000"  # Bright red
            marker_symbol = "arrow-down"
            marker_size = 20
            marker_line_color = "#000000"  # Black outline
            text = f"ENTRY SHORT<br>{signal.get('reason', '')}<br>Price: ${actual_price:.2f}"
        elif "exit_long" in signal_type:
            # Red arrow pointing down for long exits
            marker_color = "#FF0000"  # Bright red
            marker_symbol = "arrow-down"
            marker_size = 20
            marker_line_color = "#000000"  # Black outline
            pnl = signal.get("pnl", 0)
            pnl_str = f"<br>P&L: ${pnl:+.2f}" if pnl else ""
            text = f"EXIT LONG<br>{signal.get('reason', '')}<br>Price: ${actual_price:.2f}{pnl_str}"
        elif "exit_short" in signal_type:
            # Green arrow pointing up for short exits (buying back)
            marker_color = "#00FF00"  # Bright green
            marker_symbol = "arrow-up"
            marker_size = 20
            marker_line_color = "#000000"  # Black outline
            pnl = signal.get("pnl", 0)
            pnl_str = f"<br>P&L: ${pnl:+.2f}" if pnl else ""
            text = f"EXIT SHORT<br>{signal.get('reason', '')}<br>Price: ${actual_price:.2f}{pnl_str}"
        else:
            marker_color = "white"
            marker_symbol = "circle"
            marker_size = 10
            marker_line_color = "white"
            text = signal.get("reason", "")

        # Add signal marker as annotation for better visibility
        # Long: Green ▲ entry, Red ▼ exit
        # Short: Red ▼ entry, Green ▲ exit
        if "entry_long" in signal_type or "exit_short" in signal_type:
            arrow_symbol = "▲"
        else:
            arrow_symbol = "▼"

        fig.add_annotation(
            x=timestamp,
            y=actual_price,
            text=arrow_symbol,
            showarrow=False,
            font=dict(
                size=30,
                color=marker_color,
                family="Arial Black"
            ),
            xref="x",
            yref="y",
            xanchor="center",
            yanchor="middle"
        )

    return fig

def display_strategy_summary(strategy_artifact):
    """Display strategy summary and statistics"""
    st.header(f"📊 {strategy_artifact.get('strategy_name', 'Strategy')}")
    st.markdown(f"*{strategy_artifact.get('description', 'N/A')}*")

    st.divider()

    # Calculate all stats
    signals = strategy_artifact.get("signals", [])
    entries = [s for s in signals if "entry" in s["type"]]
    exits = [s for s in signals if "exit" in s["type"]]

    total_pnl = sum(s.get("pnl", 0) for s in exits)
    winning_trades = [s for s in exits if s.get("pnl", 0) > 0]
    losing_trades = [s for s in exits if s.get("pnl", 0) < 0]

    win_rate = (len(winning_trades) / len(exits) * 100) if len(exits) > 0 else 0
    avg_win = sum(s.get("pnl", 0) for s in winning_trades) / len(winning_trades) if winning_trades else 0
    avg_loss = sum(s.get("pnl", 0) for s in losing_trades) / len(losing_trades) if losing_trades else 0
    profit_factor = abs(sum(s.get("pnl", 0) for s in winning_trades) / sum(s.get("pnl", 0) for s in losing_trades)) if losing_trades and sum(s.get("pnl", 0) for s in losing_trades) != 0 else 0

    # Display metrics in organized rows
    col1, col2, col3, col4 = st.columns(4)

    with col1:
        st.metric("Symbol", strategy_artifact.get("symbol", "N/A"))
        st.metric("Timeframe", strategy_artifact.get("timeframe", "N/A"))

    with col2:
        st.metric("Total Trades", len(exits))
        st.metric("Winners / Losers", f"{len(winning_trades)} / {len(losing_trades)}")

    with col3:
        delta_color = "normal" if total_pnl >= 0 else "inverse"
        st.metric("Total P&L", f"${total_pnl:,.2f}", delta=f"${total_pnl:,.2f}", delta_color=delta_color)
        st.metric("Win Rate", f"{win_rate:.1f}%" if len(exits) > 0 else "N/A")

    with col4:
        st.metric("Avg Win", f"${avg_win:,.2f}" if avg_win else "N/A")
        st.metric("Avg Loss", f"${avg_loss:,.2f}" if avg_loss else "N/A")

    # Second row for additional metrics
    col1, col2, col3, col4 = st.columns(4)

    with col1:
        st.metric("Profit Factor", f"{profit_factor:.2f}" if profit_factor else "N/A")

    with col2:
        if winning_trades and losing_trades:
            expectancy = (win_rate/100 * avg_win) + ((1-win_rate/100) * avg_loss)
            st.metric("Expectancy", f"${expectancy:,.2f}")
        else:
            st.metric("Expectancy", "N/A")

    with col3:
        largest_win = max([s.get("pnl", 0) for s in winning_trades]) if winning_trades else 0
        st.metric("Largest Win", f"${largest_win:,.2f}" if largest_win else "N/A")

    with col4:
        largest_loss = min([s.get("pnl", 0) for s in losing_trades]) if losing_trades else 0
        st.metric("Largest Loss", f"${largest_loss:,.2f}" if largest_loss else "N/A")

    st.divider()

    # Entry conditions
    st.subheader("Entry Conditions")
    for idx, condition in enumerate(strategy_artifact.get("entry_conditions", []), 1):
        st.markdown(f"**{idx}.** {condition.get('description', 'N/A')} ({condition.get('direction', 'N/A')})")

    # Exit conditions
    st.subheader("Exit Conditions")
    for idx, condition in enumerate(strategy_artifact.get("exit_conditions", []), 1):
        st.markdown(f"**{idx}.** {condition.get('description', 'N/A')}")

    # Risk management
    risk_mgmt = strategy_artifact.get("risk_management", {})
    if risk_mgmt:
        st.subheader("Risk Management")
        col1, col2, col3 = st.columns(3)

        with col1:
            sl = risk_mgmt.get("stop_loss", {})
            st.markdown(f"**Stop Loss:** {sl.get('value', 'N/A')}% {sl.get('type', '')}")

        with col2:
            tp = risk_mgmt.get("take_profit", {})
            st.markdown(f"**Take Profit:** {tp.get('value', 'N/A')}% {tp.get('type', '')}")

        with col3:
            pos = risk_mgmt.get("position_size", {})
            st.markdown(f"**Position Size:** {pos.get('value', 'N/A')} {pos.get('type', '')}")

def main():
    st.set_page_config(
        page_title="Strategy Viewer",
        page_icon="📊",
        layout="wide",
        initial_sidebar_state="expanded"
    )

    # Custom CSS for better styling
    st.markdown("""
    <style>
        .workflow-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 2rem;
            border-radius: 1rem;
            color: white;
            margin-bottom: 2rem;
        }
        .success-box {
            background-color: #d4edda;
            border-left: 4px solid #28a745;
            padding: 1rem;
            border-radius: 0.5rem;
            margin: 1rem 0;
        }
        .info-box {
            background-color: #d1ecf1;
            border-left: 4px solid #17a2b8;
            padding: 1rem;
            border-radius: 0.5rem;
            margin: 1rem 0;
        }
        .workflow-step {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 0.5rem;
            padding: 1rem;
            margin: 0.5rem 0;
        }
    </style>
    """, unsafe_allow_html=True)

    # Header
    st.markdown("""
    <div class="workflow-header">
        <h1>📊 Strategy Viewer</h1>
        <p>Verify your code-true signals visually</p>
        <p><strong>Web Chat → Signal Codifier → Strategy Viewer</strong></p>
    </div>
    """, unsafe_allow_html=True)

    # Workflow explanation
    st.markdown("## 🔄 Your Streamlined Workflow")

    col1, col2, col3, col4 = st.columns(4)

    with col1:
        st.markdown("""
        <div class="workflow-step">
            <h4>1. Web Chat</h4>
            <p>Develop strategy with GPT</p>
            <p>Get initial JSON</p>
        </div>
        """, unsafe_allow_html=True)

    with col2:
        st.markdown("""
        <div class="workflow-step">
            <h4>2. Signal Codifier</h4>
            <p>Paste strategy JSON</p>
            <p>Generate code-true signals</p>
        </div>
        """, unsafe_allow_html=True)

    with col3:
        st.markdown("""
        <div class="workflow-step">
            <h4>3. Strategy Viewer</h4>
            <p>Verify signals visually</p>
            <p>Check performance</p>
        </div>
        """, unsafe_allow_html=True)

    with col4:
        st.markdown("""
        <div class="workflow-step">
            <h4>4. Iterate</h4>
            <p>Back to web chat</p>
            <p>Refine strategy</p>
        </div>
        """, unsafe_allow_html=True)

    st.divider()

    # Input method selection
    st.markdown("## 📝 Paste Your Strategy JSON")

    input_method = st.radio(
        "Input Method",
        ["Paste JSON", "Load Example", "Load Existing File"],
        horizontal=True
    )

    # Data source selection
    st.markdown("## 📊 Data Source")
    data_source = st.radio(
        "Data Source",
        ["Real Data (Polygon API)", "Mock Data (Testing)"],
        horizontal=True,
        help="Choose between real market data or generated mock data for testing"
    )
    use_mock_data = data_source == "Mock Data (Testing)"

    # Initialize variables (will be set based on data source)
    selected_ticker = 'SPY'
    days_back = 30
    start_date = None
    end_date = None

    # Ticker and Date Selection (when using real data)
    if not use_mock_data:
        st.markdown("## 🎯 Market Data Configuration")
        col1, col2 = st.columns(2)

        with col1:
            # Ticker selection
            available_tickers = ['SPY', 'QQQ', 'IWM', 'DIA', 'AAPL', 'MSFT', 'TSLA', 'NVDA', 'GOOGL', 'AMZN']
            selected_ticker = st.selectbox(
                "Select Ticker",
                available_tickers,
                index=1,  # Default to QQQ
                help="Choose the stock symbol for analysis"
            )

            # Date range selection
            st.markdown("### 📅 Date Range")
            date_range_option = st.radio(
                "Select Date Range",
                ["Last N Days", "Custom Range"],
                index=0,
                help="Choose how to specify the date range"
            )

            if date_range_option == "Last N Days":
                days_back = st.slider("Days of Data", 7, 90, 30, help="Days of historical data to use")
                start_date = None
                end_date = None
            else:
                col_date1, col_date2 = st.columns(2)
                with col_date1:
                    start_date = st.date_input(
                        "Start Date",
                        value=(datetime.now() - timedelta(days=30)).date(),
                        help="Start date for data analysis"
                    )
                with col_date2:
                    end_date = st.date_input(
                        "End Date",
                        value=datetime.now().date(),
                        help="End date for data analysis"
                    )
                days_back = None

        with col2:
            # Show current configuration summary
            st.markdown("### 📊 Configuration Summary")
            api_key_status = '✅ Configured' if 'POLYGON_API_KEY' in os.environ else '❌ Missing'
            st.info(f"""
            **Ticker:** {selected_ticker}
            **Data Source:** Polygon API
            **API Key:** {api_key_status}
            """)

            if 'POLYGON_API_KEY' not in os.environ:
                st.error("⚠️ POLYGON_API_KEY not found in environment variables. Please check your .env file.")

    strategy_artifact = None
    strategy_json = ""

    if input_method == "Paste JSON":
        strategy_json = st.text_area(
            "Paste your strategy JSON from Signal Codifier",
            height=300,
            placeholder=json.dumps(STRATEGY_ARTIFACT_SCHEMA, indent=2),
            key="strategy_json_input"
        )

    elif input_method == "Load Example":
        # Load code-true example
        examples = {
            "QQQ Mean Reversion": {
                "strategy_name": "QQQ_Mean_Reversion_Example",
                "description": "Multi-timeframe mean reversion strategy with pyramiding",
                "timeframe": "5min",
                "symbol": "QQQ",
                "entry_conditions": [
                    {
                        "type": "multi_timeframe_alignment",
                        "description": "HTF: Daily uptrend (50EMA > 200EMA) + MTF: 15min pullback to VWAP + LTF: 5min RSI oversold bounce",
                        "direction": "long",
                        "indicators": ["ema50", "ema200", "vwap", "rsi", "volume"],
                        "htf_condition": "Daily 50EMA above 200EMA with positive momentum",
                        "mtf_condition": "15min price pulls back to VWAP support with volume confirmation",
                        "ltf_condition": "5min RSI < 35 with bullish divergence"
                    }
                ],
                "exit_conditions": [
                    {
                        "type": "profit_target",
                        "description": "Take profit at 2R target or VWAP rejection",
                        "direction": "close_long"
                    }
                ],
                "risk_management": {
                    "stop_loss": {"type": "percentage", "value": 1.5},
                    "take_profit": {"type": "r_multiple", "value": 2.0},
                    "position_size": {"type": "r_based", "value": 1.0},
                    "pyramiding": {
                        "enabled": True,
                        "max_legs": 3,
                        "add_conditions": [
                            {"level": "initial", "size_r": 0.25, "condition": "Initial RSI bounce with volume"},
                            {"level": "confirmation", "size_r": 0.25, "condition": "Price breaks above high"},
                            {"level": "continuation", "size_r": 0.5, "condition": "Trend continuation"}
                        ]
                    }
                }
            }
        }
        selected_example = st.selectbox("Choose an example strategy", list(examples.keys()))
        strategy_artifact = examples[selected_example]
        strategy_json = json.dumps(strategy_artifact, indent=2)
        st.success(f"✅ Loaded example: {selected_example}")

    elif input_method == "Load Existing File":
        import os
        strategy_files = [f for f in os.listdir('.') if f.endswith('.json') and 'codified' in f or 'code_true' in f]
        if strategy_files:
            selected_file = st.selectbox("Choose a strategy file", strategy_files)
            try:
                with open(selected_file, 'r') as f:
                    strategy_artifact = json.load(f)
                    strategy_json = json.dumps(strategy_artifact, indent=2)
                st.success(f"✅ Loaded {selected_file}")
            except Exception as e:
                st.error(f"Error loading file: {e}")
        else:
            st.info("No codified strategy files found. Generate one with Signal Codifier first!")

    # Process the strategy if we have one
    if strategy_artifact or strategy_json:
        try:
            if not strategy_artifact:
                strategy_artifact = load_strategy_artifact(strategy_json)

            # Display strategy summary
            display_strategy_summary(strategy_artifact)

            # Get data and create chart
            st.markdown("## 📊 Strategy Chart with Signals")

            with st.spinner("📊 Fetching market data and creating chart..."):
                fig = create_strategy_chart(
                    strategy_artifact,
                    use_mock_data,
                    selected_ticker=selected_ticker if not use_mock_data else None,
                    days_back=days_back if not use_mock_data else None,
                    start_date=start_date if not use_mock_data else None,
                    end_date=end_date if not use_mock_data else None
                )

                if fig:
                    st.plotly_chart(fig, use_container_width=True)
                else:
                    st.warning("⚠️ Could not create chart. Check data availability.")

            # Show signals table
            signals = strategy_artifact.get("signals", [])
            if signals:
                st.markdown("## 📋 Signal History")
                df_signals = pd.DataFrame(signals)

                # Reorder columns to show important info first
                preferred_order = ['timestamp', 'type', 'price', 'shares', 'execution', 'calculation', 'pnl', 'reason', 'position_id', 'leg', 'r_allocation']
                columns = [col for col in preferred_order if col in df_signals.columns]
                columns += [col for col in df_signals.columns if col not in columns]
                df_signals = df_signals[columns]

                # Format columns
                st.dataframe(
                    df_signals,
                    use_container_width=True,
                    column_config={
                        "pnl": st.column_config.NumberColumn(
                            "P&L",
                            format="$%.2f",
                            help="Profit/Loss for this trade"
                        ),
                        "price": st.column_config.NumberColumn(
                            "Price",
                            format="$%.2f"
                        ),
                        "r_allocation": st.column_config.NumberColumn(
                            "R Allocation",
                            format="%.2f"
                        ),
                        "shares": st.column_config.NumberColumn(
                            "Shares",
                            format="d"
                        ),
                        "execution": st.column_config.TextColumn(
                            "Execution",
                            width="large"
                        ),
                        "calculation": st.column_config.TextColumn(
                            "Calculation",
                            width="large"
                        )
                    }
                )

            # Show provenance information
            provenance = strategy_artifact.get("provenance", {})
            if provenance:
                st.markdown("## 🔍 Signal Provenance")
                col1, col2 = st.columns(2)

                with col1:
                    st.write(f"**Generated by:** {provenance.get('generated_by', 'Unknown')}")
                    st.write(f"**Data Source:** {provenance.get('data_source', 'Unknown')}")
                    st.write(f"**Rule Version:** {provenance.get('rule_version', 'Unknown')}")

                with col2:
                    st.write(f"**Generation Timestamp:** {provenance.get('generation_timestamp', 'Unknown')}")
                    st.write(f"**Code Hash:** {provenance.get('code_hash', 'Unknown')}")

            # Next steps
            st.markdown("## 🚀 Next Steps")
            st.markdown("""
            <div class="info-box">
                <h4>📋 Strategy Verification Complete!</h4>
                <p><strong>Your signals have been verified visually.</strong></p>
                <ol>
                    <li>Check if the signals look correct on the chart</li>
                    <li>Review the performance metrics</li>
                    <li>If satisfied, proceed to VectorBT backtesting</li>
                    <li>If not, go back to web chat for refinements</li>
                </ol>
                <p><em>Remember: These are code-true signals generated by the Signal Codifier!</em></p>
            </div>
            """, unsafe_allow_html=True)

        except json.JSONDecodeError as e:
            st.error(f"❌ Invalid JSON: {str(e)}")
        except Exception as e:
            st.error(f"❌ Error processing artifact: {str(e)}")
            st.exception(e)

    # Footer
    st.markdown("---")
    st.markdown("""
    <div style="text-align: center; color: #666;">
        <p>Strategy Viewer - Part of your streamlined workflow</p>
        <p>Web Chat → Signal Codifier → Strategy Viewer → VectorBT</p>
    </div>
    """, unsafe_allow_html=True)

# The main code runs at module level for Streamlit
